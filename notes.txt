##### 29 May 2015 - 4:15 pm Update #####

- added ConstraintSet container class
    - method chaining allows

- renamed problem.constraint to problem.constraints
- add equivalence override to State class
- first attempt at automating BC creation

- TODO: Create a "chainable list" class for general use?
    - Can be used for constraints, continuation set etc.

##### 29 May 2015 - 3:15 pm Update #####

- made "Beluga" class
    - class method run() that takes a problem object, instantiates a Beluga object and calls solve()
    - run() is just there to make things easier for user. 
    - moved run_optim into the Beluga.solve method
    - created run_continuation_set() method
        - clarify how initial guess is treated
        
- renamed bvpsol.Problem to bvpsol.BVP to avoid any naming clash

- moved compute_necessary_conditions into a get_bvp method in   NecessaryConditions which also creates a BVP object to return to Beluga

- modified ContinuationStep class to allow chaining
    - created num_cases() into a method that either sets or gets num_cases
    
- create ContinuationSet class subclassing list
    - add_step() function allows adding steps using chaining

- removed FunctionTemplate.py and added compile() to NecessaryConditions
- change inputFile.py into a script
    - added continuation steps list (need to rethink representation of steps)
    - added bvp solver as input option
    - added initial guess option
    - added example to show three ways to implement chaining

- added automation to __init__ files

TODO:
* create BelugaConfig class to describe solver configuration
  such as output directory, restart options etc.

